# 9.1 옵티마이저     

사용자가 입력한 쿼리의 최적의 실행 계획을 수립하는 작업을 담당한다 mysql 서버에 포함한 대부분의 DBMS들이 이러한 옵티마이저 기능을 담당한다.

    SQL 쿼리실행 절차 참고     
        FROM 
        ON 
        JOIN 
        GROUP BY
        ORDER BYd
        LIMIT 
        SELECT 
    순으로 진행된다.

1. 사용자로 부터 요청된 쿼리에서 문장을 잘게 쪼개서 MYSQL 서버가 이해할수있는 수준으로 분리(파스트리) 한다.

2. SQL 파싱 정보(파스트리)을 확인하여 어떤 테이블부터 읽고  어떤 인텍스를 읽을지 선택한다

3. 두번째 단계에서 결정된 읽기순서나 인덱스 정보을 이용해서 스트리지 엔진(inndodb) 데이터를 가져온다

### 옵티마이저 종류

-  규칙 기반 : 최적화을 고려하지 않고 쿼리에 순서대로 처리하는 방식
-  비용 기반 : 최적화 쿼리를 처리하기 위해 여러가지 방법을 만들어서 실행하는 기반

-----------------------------------------

# 9.2 기본 데이터 처리
    
풀 테이블 스캔과 풀 인덱스 스캔

## 풀 테이블 스캔 : 
- 일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 처음부터 끝까지 읽는 작업은 상당한 양에 디스크 읽기 작업 필요하다.
하지만 연속된 작업이 계속되는 경우 리드 헤드을 통해서 앞으로 데이터을 버퍼에 적재해서 포그라운드 쓰레드에서 해당 버퍼을 읽어서 처리해서 가면 갈수록 속도가 빨리지는 효과을 볼수 있다    

- 리드어헤드을 사용하기 위해서는 innodb_read_ahead_htrshold 시스템 변수을 사용해서 리드어헤드을 임계값을 설정할수 있다 
ex) 리드 어헤드 옵션에서 데이터페이지수 갯수 (리드어헤드 시작할 데이터페이지에 임계값 설정)을 설정해서 리드어헤드을 유도 할수 있다

----------------------
### 9.2.2 병렬처리 

mysql 8.0에서는 여러개에 쓰레드을 통해 한쿼리을 병렬처리 할수 있다

    SET SESSION innodb_parallel_read_hreads=1; -- 쓰레드갯수 
    SELECT COUNT(*) FROM salaries; 

ex) 쓰레드 갯수가 많아질수록 속도가 빨라진다 하지만
한쿼리에 많은 작업이 필요해서 cpu 코어개수을 넘어서는 
경우 오히려 성능저하가 있을수 있다.

----------------------
### 9.2.3 order by 처리(useing filesort)

정렬처리는 filesort와 index을 사용하는 방식으로 나눌수 있다
<table style="border:1px solid #cccc">
<tbody>
<tr>
    <th colspan="2">index </th>
    <th colspan="1">filesort</th>
</tr>

<tr>
    <th>장점</th>      
    <td>
        select,update등 인덱스가 이미 정렬 되있어서
        매우 빠르다
    </td>
    <td>
        인덱스을 생성 안해도 되서 insert update 작업시 index 컬럼을 추가 ,삭제
        작업을 안해서 매우 빠르다
    </td>
</tr>
<tr>
    <th>단점</th>        
    <td>
        filesort 장점과 반대로 insert,update,delete시 추가해야되서 매우느리다
    </td>
    <td>
        정렬 작업시 레코드가 많을경우 쿼리에 응답속도가 매우 느리다
    </td>
</tr>
<thead>
<table>

이와같이 웹페이지 구성상 select 작업이 많이 있는데 index을 사용해서 정렬하면
매우 좋치만 그러지 못하는 상황들이 있다

1. 정렬기준이 너무많아서 index를 생성하는것이 불가능할경우
2. group by 결과 또는 distinct 같은 처리의 결과 정렬할경우
3. union결과와 같이 임시테이블로 처리할 경우
4. 랜덤하게 결과 레코드을 가져와야될 경우

### 9.2.3.1 소트버퍼
- filesort가 나올경우 mysql을 소트버퍼에서 정렬후 값을 넘겨준다 이때 소트버프에 크기는 sort_buffer_size 설정할수 있다

<br>

### 멀티 머지 
- 데이터 크기가 너무커서 데이터 페이지으로 나눠서 머지을 해야되는 경우가 있는데 이때 소트버퍼 공간에서 정렬한 값을 임시테이블에 저장한후 다시 다음 데이터페이지를 소트버퍼에서 정렬후 임시테이블에 데이터와 병합 하는 과정을 말한다 이때 병합 횟누는 sort_marge_passes라는 변수을 통해서 알수 있다.

<br>

## 9.2.3.2 정렬 알고리즘
레코드를 정렬할떄 소트버퍼에 정렬기준 칼럼만 담을지 칼럼전체을 소트버퍼에 담을지에 따라  싱글패스,더블 패스로 나눈다


------------------------------------------------------------------------
<br>

### 싱글패스 정렬 방식

- 사용자가 보낸 쿼리중 칼럼값을 전부 포함해서 소트버퍼에 담아서 멀티머지을 실행후 쿼리결과을 반환 하는 방식이다 (데이터양이 적으면 이방법이 효율적이다)

<br>

#### 더블패스 정렬 방식
-  사용자에 보낸 쿼리중 기준이 되는 칼럼만 포함후 멀티머지 과정을 한후에 
기준칼럼 기준으로 나머지 칼럼값을 조회해서 가져오는 방식이다
(데이터 양이 많이면 효율적이다)

### 9.2.3.3 정렬 처리 방법
<br>
다음 같이 세가지 방식있다.
<table style="border:1px solid #cccc">
<tbody>
<tr>
    <td>
        정렬 처리 방법
    </td>
    <td>
        실행 계획의 extra 칼럼 내용
    </td>
</tr>
<tr>

<tr>
    <td>인덱스를 사용한 정렬</td>
    <td> 별도 표기 없음</td>
</tr>

<tr>
    <td>조인에 드라이빙 테이블에 칼럼으로 정렬 방식</td>
    <td>Using filesort</td>
</tr>

<tr>
    <td>조인에서 조인 결과를 임시테이블로 저장후 정렬</td>
    <td> using temorary; using filesort</td>
</tr>

</tbody>
</table>
가 표시 된다.

위에 세가지 방식중  옵티마이저는 정렬 대상을 최소하 하기위해서 

- 조인에 드라이빙 테이블을 정렬후 다음 조인 수행 (위 첫번쨰 방법)
- 조인이 끝나고 일치하는 레코드를 가져와서 정렬 (위 두번째방법)

<br>

-------------------------------

## 인덱스를 이용한 정렬

- 조인과정에서 드라이빙 테이블을 정렬한 후 드리븐 테이블에서 join 하는 방법이다 이 방법으로 사용하면 최적화된 조인을 사용할수 있다

<br>

## 조인의 드라이빙 테이블만 정렬
- 조인과정에서 드라이빙 테이블에서 인덱스가 아닌 칼럼으로 정렬한 후 join  하는 방법다 이때 정렬과정에서 소트버퍼을을 사용해야 하기 인덱스를 이용한 정렬보다는 느리다.

<br>

## 임시 테이블을 이용한 정렬
-join 과정에서 드라이빙 테이블이 아닌 드리븐 테이블에 칼럼으로 때문에 조인을 
할 경우 임시 테이블이 생성된다 수행한 다음에 정렬 과정을 수행해야 되기 떄문에 임시테이블을 생성 해야된다 위에서 설명 3가지방법 중에서 제일 느리면 제일 피해야되는 방법이다.

<br>

-----------------------------

<br>

## 정렬 방법과 성능 비교

웹사이트에서 ORDER BY와 LIMIT는 거의 필수적으로 사용된다 LIMIT을 사용하면 테이블에 일부결과만 가져와서 성능을 높힐수 있는데 그러치 못한 상황들 있다. GROUP,ORDER을 사용하면 전체 데이터을 그룹화랑,정렬 과정을 수행해야되서 LIMIT을 사용하든 안하든 속도면서 동일하다 
이떄 스트리밍 방식과 버퍼링 방식이 있는 알아보자

스트리밍 방식: 
- 데이터을 즉시 반화해서 LIMIT 절 사용시 해당 ROW값만 가져온다

버퍼링 방식
- GROUP BY, ORDER BY 사용시 전체 데이터 버퍼에 담아서  그룹화 ,정렬 과정을 수행하는 방식이다  전체 데이터을 정렬후 데이터을 가져오는 방식이여서 LIMIT절을 사용한다고 해도 속도측에서 보장 할수 없다.
<br>

-----------------------------
<br>

## 정렬 관련 상태 변수

- Sort_marge_passes:  멀티 머지 처리 횟수
- Sort_range는 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬이다
- sort_scan 풀테이블 스캔을 통해 검색결과에 대한 정렬한 작업 횟수이다




























                       






    




    
